KK[,i] = K
A = TT %*% A + K %*% E
AA[,((i*ncA0+1):((i+1)*ncA0))] = A
L = TT-K%*%Z
P = L%*%P%*%t(TT) + HHt
PP[,((i*lTT+1):((i+1)*lTT))] = P
if (i>2){
SS = QQ[(1:lTT),(1:lTT)]
#print(eigen(SS)$values)
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
mse.ee[i] = EEgam%*%SSinv%*%t(EEgam)}
#junk<-t(E)%*%Dinv%*%E
#print(eigen(junk)$values)
QQ = QQ+t(E)%*%Dinv%*%E}
SS
i=1
sigma.eps = 1
sigma.gnu = vec[1]
sigma.eta = vec[2]
delta = vec[3]
rho = 1
y = YY
ll = length(y)
aux = c(rho, 1, 0, delta)
TT = matrix(aux, 2, 2, byrow=T)
#print(TT)
lTT = nrow(TT)
A = cbind(diag(-1, lTT), rep(0,lTT))
#print(A)
ncA0 = ncol(A)
QQ = matrix(0, ncA0, ncA0)
DD = rep(0, ll)
EE = matrix(0, 1, (ncA0*ll))
AA = matrix(rep(0, ncA0 * lTT * (ll + 1)), lTT, (ncA0 * (ll + 1)))
AA[,(1:ncA0)] = A
PP = matrix(rep(0,(lTT*lTT*(ll+1))),lTT,(lTT*(ll+1)))
KK = matrix(rep(0,(lTT*ll)),lTT,ll)
elem = c((sigma.gnu^2), 0, 0, (sigma.eta^2))
HHt = matrix(elem,lTT,lTT,byrow=T)
P = matrix(0 ,lTT,lTT)
PP[ ,(1:lTT)] = P
ee = rep(0,ll)
mse.ee = rep(0,ll)
Z = matrix(c(1,0),1,lTT)
GGt = sigma.eps^2
aux2 = matrix(c(rep(0,(ncA0-1)),y[i]),1,ncA0)
E = aux2-Z%*%A
EE[,((i-1)*ncA0+1):(i*ncA0)] = E
EEgam = matrix(E[,(1:lTT)],1,lTT)
D = Z%*%P%*%t(Z) + GGt
DD[i] = D
Dinv = 1/D
K = TT %*% P %*% t(Z) %*% Dinv
KK[,i] = K
A = TT %*% A + K %*% E
AA[,((i*ncA0+1):((i+1)*ncA0))] = A
L = TT-K%*%Z
P = L%*%P%*%t(TT) + HHt
PP[,((i*lTT+1):((i+1)*lTT))] = P
SS = QQ[(1:lTT),(1:lTT)]
SS
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
gamma
aux = matrix(c(-gamma,1),ncA0,1)
aux
gamma
matrix(c(-gamma,1),ncA0,1)
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
EEgam%*%SSinv%*%t(EEgam)
EEgam
SSinv
SS
SSinv = solve(SS)
remove(SSinc)
remove(SSinv)
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
mse.ee[i] = EEgam%*%SSinv%*%t(EEgam)}
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
mse.ee[i] = EEgam%*%SSinv%*%t(EEgam)
sigma.eps = 1
sigma.gnu = vec[1]
sigma.eta = vec[2]
delta = vec[3]
rho = 1
y = YY
ll = length(y)
aux = c(rho, 1, 0, delta)
TT = matrix(aux, 2, 2, byrow=T)
#print(TT)
lTT = nrow(TT)
A = cbind(diag(-1, lTT), rep(0,lTT))
#print(A)
ncA0 = ncol(A)
QQ = matrix(0, ncA0, ncA0)
DD = rep(0, ll)
EE = matrix(0, 1, (ncA0*ll))
AA = matrix(rep(0, ncA0 * lTT * (ll + 1)), lTT, (ncA0 * (ll + 1)))
AA[,(1:ncA0)] = A
PP = matrix(rep(0,(lTT*lTT*(ll+1))),lTT,(lTT*(ll+1)))
KK = matrix(rep(0,(lTT*ll)),lTT,ll)
elem = c((sigma.gnu^2), 0, 0, (sigma.eta^2))
HHt = matrix(elem,lTT,lTT,byrow=T)
P = matrix(0 ,lTT,lTT)
PP[ ,(1:lTT)] = P
ee = rep(0,ll)
mse.ee = rep(0,ll)
for (i in 1:ll){
Z = matrix(c(1,0),1,lTT)
GGt = sigma.eps^2
aux2 = matrix(c(rep(0,(ncA0-1)),y[i]),1,ncA0)
E = aux2-Z%*%A
EE[,((i-1)*ncA0+1):(i*ncA0)] = E
EEgam = matrix(E[,(1:lTT)],1,lTT)
D = Z%*%P%*%t(Z) + GGt
DD[i] = D
Dinv = 1/D
K = TT %*% P %*% t(Z) %*% Dinv
KK[,i] = K
A = TT %*% A + K %*% E
AA[,((i*ncA0+1):((i+1)*ncA0))] = A
L = TT-K%*%Z
P = L%*%P%*%t(TT) + HHt
PP[,((i*lTT+1):((i+1)*lTT))] = P
if (i>2){
SS = QQ[(1:lTT),(1:lTT)]
#print(eigen(SS)$values)
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
mse.ee[i] = EEgam%*%SSinv%*%t(EEgam)}
#junk<-t(E)%*%Dinv%*%E
#print(eigen(junk)$values)
QQ = QQ+t(E)%*%Dinv%*%E}
QQ
#DKF
#locally linear trend - time varying drift#
###########################################
#This is the DKF
# The state space form is
#     y(x)  =  Z(x)*alpha(x) + G*u(x)
#alpha(x+1) = TT*alpha(x) + H*u(x)
# the DKF is initialized with A0 and P0 (Q0=0).
#
#sigma.eps^2 is concentrated out
#
dkf.llm.vard = function(vec, YY){
sigma.eps = 1
sigma.gnu = vec[1]
sigma.eta = vec[2]
delta = vec[3]
rho = 1
y = YY
ll = length(y)
aux = c(rho, 1, 0, delta)
TT = matrix(aux, 2, 2, byrow=T)
#print(TT)
lTT = nrow(TT)
A = cbind(diag(-1, lTT), rep(0,lTT))
#print(A)
ncA0 = ncol(A)
QQ = matrix(0, ncA0, ncA0)
DD = rep(0, ll)
EE = matrix(0, 1, (ncA0*ll))
AA = matrix(rep(0, ncA0 * lTT * (ll + 1)), lTT, (ncA0 * (ll + 1)))
AA[,(1:ncA0)] = A
PP = matrix(rep(0,(lTT*lTT*(ll+1))),lTT,(lTT*(ll+1)))
KK = matrix(rep(0,(lTT*ll)),lTT,ll)
elem = c((sigma.gnu^2), 0, 0, (sigma.eta^2))
HHt = matrix(elem,lTT,lTT,byrow=T)
P = matrix(0 ,lTT,lTT)
PP[ ,(1:lTT)] = P
ee = rep(0,ll)
mse.ee = rep(0,ll)
for (i in 1:ll){
Z = matrix(c(1,0),1,lTT)
GGt = sigma.eps^2
aux2 = matrix(c(rep(0,(ncA0-1)),y[i]),1,ncA0)
E = aux2-Z%*%A
EE[,((i-1)*ncA0+1):(i*ncA0)] = E
EEgam = matrix(E[,(1:lTT)],1,lTT)
D = Z%*%P%*%t(Z) + GGt
DD[i] = D
Dinv = 1/D
K = TT %*% P %*% t(Z) %*% Dinv
KK[,i] = K
A = TT %*% A + K %*% E
AA[,((i*ncA0+1):((i+1)*ncA0))] = A
L = TT-K%*%Z
P = L%*%P%*%t(TT) + HHt
PP[,((i*lTT+1):((i+1)*lTT))] = P
if (i>2){
SS = QQ[(1:lTT),(1:lTT)]
#print(eigen(SS)$values)
SSinv = solve(SS)
ss = QQ[(1:lTT),((lTT+1):ncA0)]
gamma = SSinv%*%ss
aux = matrix(c(-gamma,1),ncA0,1)
ee[i] = E%*%aux
mse.ee[i] = EEgam%*%SSinv%*%t(EEgam)}
#junk<-t(E)%*%Dinv%*%E
#print(eigen(junk)$values)
QQ = QQ+t(E)%*%Dinv%*%E}
Alast = A
Plast = P
SS = QQ[(1:lTT),(1:lTT)]
aux = eigen(SS)$values
#print(aux)
ldSS = sum(log(aux))
qqq = as.matrix(QQ[((lTT+1):ncA0),((lTT+1):ncA0)])
ss = QQ[(1:lTT),((lTT+1):ncA0)]
Sinv = solve(SS)
gamma.est = Sinv %*% ss
sigma2.est = (qqq-t(ss) %*% Sinv %*% ss)/ll
sigma2.est = as.numeric(sigma2.est)
mse.gamma.est = sigma2.est*Sinv
mse.ee = sigma2.est * (DD + mse.ee)
l0 = (-0.5) * (ll*(1 + log(sigma2.est)) + sum(log(abs(DD))))
sigmatilde2 = (ll/(ll - ncA0 + 1)) * sigma2.est
linfty = (-0.5)*((ll-ncA0+1)*(1 + log(sigmatilde2)) + ldSS + sum(log(abs(DD))))
ee.std = ee/sqrt(mse.ee)
list(gamma.est = gamma.est, mse.gamma = mse.gamma.est, linfty = linfty, l0 = l0, ncA0 = ncA0, ll = ll, delta = delta,
D=DD, E=EE, Z=Z, A = AA, P = PP, K = KK, TT = TT, y = y, ee = ee, mse.ee = mse.ee, ee.std = ee.std, Alast = Alast, Plast = Plast,
sigma2 = sigma2.est,
sigma.eps2 = sigma2.est*sigma.eps^2,
sigma.gnu2 = sigma2.est*sigma.gnu^2,
sigma.eta2 = sigma2.est*sigma.eta^2,
sigma.eps = sqrt(sigma2.est*sigma.eps^2),
sigma.gnu = sqrt(sigma2.est*sigma.gnu^2),
sigma.eta = sqrt(sigma2.est*sigma.eta^2)
)}
dkf.llm.vard (vector, YY)
dfk.out = dkf.llm.vard (vector, YY)
y = dkf.out$y
ll = length(y)
TT = dkf.out$TT
lTT = ncol(TT)
ncA0 = dkf.out$ncA0
N = matrix(0,lTT,ncA0)
R = matrix(0,lTT,lTT)
Z = dkf.out$Z
ncolZ = ncol(Z)
gamma.est = dkf.out$gamma.est
mse.gamma = as.matrix(dkf.out$mse.gamma)
sigma2 = as.numeric(dkf.out$sigma2)
alphahat = matrix(0,ncolZ,ll)
mse.alphahat = matrix(0,lTT,lTT*ll)
i=1
tZ = t(Z)
(ll-i+1)
D = dkf.out$D[(ll-i+1)]
D
dkf.out$D
View(dfk.out)
dfk.out[["D"]]
dkf.out$D
dkf.out
remove(dfk.out)
View(dkf.out)
dkf.out = dkf.llm.vard (vector, YY)
dkf.out$D
dkf.out$D[(ll-i+1)]
y = dkf.out$y
ll = length(y)
TT = dkf.out$TT
lTT = ncol(TT)
ncA0 = dkf.out$ncA0
N = matrix(0,lTT,ncA0)
R = matrix(0,lTT,lTT)
Z = dkf.out$Z
ncolZ = ncol(Z)
gamma.est = dkf.out$gamma.est
mse.gamma = as.matrix(dkf.out$mse.gamma)
sigma2 = as.numeric(dkf.out$sigma2)
alphahat = matrix(0,ncolZ,ll)
mse.alphahat = matrix(0,lTT,lTT*ll)
tZ = t(Z)
D = dkf.out$D[(ll-i+1)]
D
dkf.out$E[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
((ll*ncA0-ncA0*i+1)
)
(ncA0*ll-ncA0*(i-1)))
(ncA0*ll-ncA0*(i-1))
i=2
dkf.out$E[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
i=1
E = dkf.out$E[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
A = dkf.out$A[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
P = dkf.out$P[,((ll*ncolZ-ncolZ*i+1):(ncolZ*ll-ncolZ*(i-1)))]
P
dkf.out$K[,(ll-i+1)]
K = matrix(dkf.out$K[,(ll-i+1)],ncolZ,1)
K
L = TT-K%*%Z
Dinv = 1/D
Dinv
tL = t(L)
junk = Dinv*tZ
N = junk%*%E +tL%*%N
N
R = Dinv * (tZ %*% Z) + tL %*% R %*% L
R
Naux = (A + P %*% N)
Naux
Naux2 = Naux %*% matrix(c(-gamma.est, 1), ncA0, 1)
Naux2
mse = (sigma2 * (P - P %*% R %*% P))+(Naux2 %*% mse.gamma %*% t(Naux2))
mse.gamma
Naux2
y = dkf.out$y
ll = length(y)
TT = dkf.out$TT
lTT = ncol(TT)
ncA0 = dkf.out$ncA0
N = matrix(0,lTT,ncA0)
R = matrix(0,lTT,lTT)
Z = dkf.out$Z
ncolZ = ncol(Z)
gamma.est = dkf.out$gamma.est
mse.gamma = as.matrix(dkf.out$mse.gamma)
sigma2 = as.numeric(dkf.out$sigma2)
alphahat = matrix(0,ncolZ,ll)
mse.alphahat = matrix(0,lTT,lTT*ll)
tZ = t(Z)
D = dkf.out$D[(ll-i+1)]
E = dkf.out$E[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
A = dkf.out$A[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
P = dkf.out$P[,((ll*ncolZ-ncolZ*i+1):(ncolZ*ll-ncolZ*(i-1)))]
K = matrix(dkf.out$K[,(ll-i+1)],ncolZ,1)
L = TT-K%*%Z
Dinv = 1/D
Dinv = as.numeric(Dinv)
tL = t(L)
junk = Dinv*tZ
N = junk%*%E +tL%*%N
R = Dinv * (tZ %*% Z) + tL %*% R %*% L
Naux = (A + P %*% N)
Naux2 = Naux %*% matrix(c(-gamma.est, 1), ncA0, 1)
alphahat[,ll-i+1] = Naux2
Naux2 = matrix(Naux[,(1:(ncA0-1))],lTT,(ncA0-1))
mse = (sigma2 * (P - P %*% R %*% P))+(Naux2 %*% mse.gamma %*% t(Naux2))
mse.gamma
sigma2
P
R
Naux2
y = dkf.out$y
ll = length(y)
TT = dkf.out$TT
lTT = ncol(TT)
ncA0 = dkf.out$ncA0
N = matrix(0,lTT,ncA0)
R = matrix(0,lTT,lTT)
Z = dkf.out$Z
ncolZ = ncol(Z)
gamma.est = dkf.out$gamma.est
mse.gamma = as.matrix(dkf.out$mse.gamma)
sigma2 = as.numeric(dkf.out$sigma2)
alphahat = matrix(0,ncolZ,ll)
mse.alphahat = matrix(0,lTT,lTT*ll)
tZ = t(Z)
D = dkf.out$D[(ll-i+1)]
E = dkf.out$E[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
A = dkf.out$A[,((ll*ncA0-ncA0*i+1):(ncA0*ll-ncA0*(i-1)))]
P = dkf.out$P[,((ll*ncolZ-ncolZ*i+1):(ncolZ*ll-ncolZ*(i-1)))]
K = matrix(dkf.out$K[,(ll-i+1)],ncolZ,1)
L = TT-K%*%Z
Dinv = 1/D
Dinv = as.numeric(Dinv)
tL = t(L)
junk = Dinv*tZ
N = junk%*%E +tL%*%N
R = Dinv * (tZ %*% Z) + tL %*% R %*% L
Naux = (A + P %*% N)
Naux2 = Naux %*% matrix(c(-gamma.est, 1), ncA0, 1)
alphahat[,ll-i+1]
alphahat[:, ll - i - 1] = Naux2
Naux2
alphahat[,ll-i+1]
alphahat
alphahat[,ll-i+1] = Naux2
alphahat
sigma2
P
R
Naux2
mse.gamma
mse.gamma %*% t(Naux2)
Naux = (A + P %*% N)
Naux2 = Naux %*% matrix(c(-gamma.est, 1), ncA0, 1)
alphahat[,ll-i+1] = Naux2
Naux2 = matrix(Naux[,(1:(ncA0-1))],lTT,(ncA0-1))
mse.gamma %*% t(Naux2)
mse.gamma
Naux2
t(Naux2)
Naux
gamma_est
gamma.est
Naux
Naux2 = Naux %*% matrix(c(-gamma.est, 1), ncA0, 1)
Naux2
alphahat[,ll-i+1] = Naux2
Naux[,(1:(ncA0-1))
]
Naux2 = matrix(Naux[,(1:(ncA0-1))],lTT,(ncA0-1))
Naux2
mse = (sigma2 * (P - P %*% R %*% P))+(Naux2 %*% mse.gamma %*% t(Naux2))
mse
(lTT * (ll - i) + 1): (lTT * (ll - i + 1))
mse.alphahat
mse.alphahat[, (lTT*(ll-i)+1) : (lTT*(ll-i+1)) ]
#This is the function that computes the likelihood for LLM with a time varying drift (second component of alpha)
#need
#YY: time series
#
lik.llm.vard<-function(vec){
sigma.eps = 1
sigma.gnu = vec[1]
sigma.eta = vec[2]
delta = vec[3]
rho = 1
y = YY
ll = length(y)
aux = c(rho,1,0,delta)
TT = matrix(aux,2,2,byrow=T)
lTT = nrow(TT)
A = cbind(diag(-1,lTT),rep(0,lTT))#
ncA0 = ncol(A)
QQ = matrix(0,ncA0,ncA0)
DD = rep(0,ll)
elem = c((sigma.gnu^2),0,0,(sigma.eta^2))
HHt = matrix(elem,lTT,lTT,byrow=T)
P0 = matrix(0, lTT, lTT)
P = P0
Z = matrix(c(1,0),1,lTT)
#
for (i in 1:ll){
GGt = sigma.eps^2
aux2 = matrix(c(rep(0,(ncA0-1)),y[i]),1,ncA0)
E = aux2-Z%*%A
D = Z%*%P%*%t(Z) + GGt
DD[i] = D
Dinv = 1/D
K = TT %*% P %*% t(Z) %*% Dinv
A = TT %*% A + K %*% E
L = TT - K %*% Z
P = L %*% P %*% t(TT) + HHt
QQ = QQ + t(E) %*% Dinv %*% E
}
#print(QQ)
#
SS = QQ[(1:lTT),(1:lTT)]
aux = eigen(SS)$values
ldSS = sum(log(aux))
qqq = as.matrix(QQ[((lTT+1):ncA0),((lTT+1):ncA0)])
ss = QQ[(1:lTT),((lTT+1):ncA0)]
Sinv = solve(SS)
gamma.est = Sinv %*% ss
sigma2.est = (qqq - t(ss) %*% Sinv %*% ss)/ll
sigma2.est = as.numeric(sigma2.est)
sigmatilde2 = (ll/(ll-ncA0+1))*sigma2.est
#linfty<-(-0.5)*((ll-ncA0+1)*(1+log(sigmatilde2))+ldSS+sum(log(abs(DD))))
loglik = (-0.5)*((ll-ncA0+1)*(1+log(sigmatilde2))+sum(log(abs(DD))))
-loglik}
# This function returns the value of minus the log-likelihood at the local
# minimum detected by nlminb with startng value for the search x.
minimizer <- function(x){
source("likelihoodLLMvard.R")
nlminb(x, lik.llm.vard, lower = c(-Inf,-Inf, 0), upper = Inf )$objective
}
x1 <- c(0.01,0.1,0.5,1,10)
x2 <- x1
x3 <- c(0.5,0.7,0.9)
grid <- expand.grid(x1, x2, x3)
View(grid)
min_out <- apply(grid, 1, minimizer)
source("minimizer.R")
min_out <- apply(grid, 1, minimizer)
source("minimizer.R")
min_out <- apply(grid, 1, minimizer)
grid
1
minimizer()
# This function returns the value of minus the log-likelihood at the local
# minimum detected by nlminb with startng value for the search x.
minimizer <- function(x){
source("likelihoodLLMvard.R")
nlminb(x, lik.llm.vard, lower = c(-Inf,-Inf, 0), upper = Inf )$objective
}
min_out <- apply(grid, 1, minimizer)
min_out <- apply(grid, 1, minimizer)
source("likelihoodLLMvard.R")
